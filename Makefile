
SRC1 = cpu.py
SRC2 = utils.py
SRC3 = main.fut
EXE3 = main
ENTRY = main
SRC4 = partition.fut
EXE4 = partition


virtual: 
	virtualenv -p python3 annfield

activate: 
	source annfield/bin/activate

install: 
	pip install -r requirements.txt

# Initial command to setup tools and requirements.
init: virtual activate install

# Run the main python program. 
runpy:
	python $(SRC1)


# Compile futhark brute-force implementation with opencl.
compile-fut:
	futhark opencl $(SRC3)


# Run the futhark brute-force implementation.
runfut: compile-fut
	./$(EXE3)


# Run tests of the futhark brute-force implementation.
runtestfut: 
	futhark test --backend=opencl $(SRC3)


# futhark bench --backend=opencl -r 1 main.fut
# Benchmark multiple datasets with the below, -e denotes the entrypoint.
bench: 
	futhark bench --backend=opencl -e $(ENTRY) -r 3 $(SRC3)
	futhark bench --backend=opencl -e $(ENTRY) -r 3 $(SRC4)


# Creating a Python module of the futhark brute-force implementation with pyopencl. 
compile-futlib: 
	futhark pyopencl --library $(SRC3)


makedata:
	./makedata.sh


# Profile info for a file-saved dataset.
profile-saved: compile-fut
	./$(EXE1) -P < data/dataset.in


# Detailed profile info for a autogenerated dataset of the futhark brute-force implementation.
# profile-auto-detailed:
# 	futhark dataget $(SRC3) "[35170][8]f32 [35170][8]f32" | ./$(EXE1) -D -e $(ENTRY) > /dev/null


# # Simple profile info for a autogenerated dataset of the futhark brute-force implementation.
# profile-auto-simple:
# 	futhark dataget $(SRC3) "[35170][8]f32 [35170][8]f32" | ./$(EXE1) -P -e $(ENTRY) > /dev/null


# # For printing the runtime without futhark bench of the futhark brute-force implementation.
# profile-auto-runtime:
# 	futhark dataget $(SRC3) "[35170][8]f32 [35170][8]f32" | ./$(EXE1) -t /dev/stderr -r 20 -e $(ENTRY) > /dev/null


profile:
	./runrandom.sh


