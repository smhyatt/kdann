\subsection{The Full Implementation}
\label{sec:full}
% At each step you reason about tradeoffs/alternative design choices and
% justify why you did it in the way you did it (advantages/shortcommings,
% and why your approach is reasonable). Of course mostly related to performance.

% Whenever possible, support your reasoning with (as in point to) experimental
% evaluation results (next).

% 3.4 The Full Implementation
%       - explain how things are put together - main function
%       - reason about sorting the queries by the leaves - why is it faster? optimises locality of reference, temporal locality because by sorting the queries by the leaves the same leaves are accessed in order. 


Listing \ref{lst:full} shows, in pseudo-code, the overall structure of the main function that puts all parts together. We experiment with two solutions for splitting the queries that have found their KNN, with the ones that need to continue traversing the tree. The first solution is using the two-way partition, elaborated further in section \ref{sec:pard}. The second solution is to sort the queries by the leaves, and this is elaborated further in section \ref{sec:sord}. 
\\[2mm]
The structure of Listing \ref{lst:full} is as follows. The first step is building the tree of the reference points, on line 3. The second step is to perform the first traversal for each query to the leaves in which the queries naturally belong, on line 4. The third step is a sequential outer while-loop, on lines 12-37, which continues to iterate until all queries have found their KNN. 
\\[2mm]
Inside this loop, we have a parallel map which performs two main tasks, (1) performing brute force on each ongoing query with its current leaf, in line 19, and (2) traversing the tree to find new leaves for the ongoing queries, on line 21. 
\\[2mm]
On lines 25-29, we either sort or partition the completed queries, from the non-completed queries. Since both partition and sorting reorganise the contents of the arrays, they do not change the sizes of them. Thus, in lines 31-37 the arrays are cut for the next iteration of the loop.

\begin{listing}[H]
\begin{minted}{haskell}
entry main [n][m][d] (k: i32) (h: i32) (qs : [m][d]f32) (refs : [n][d]f32) =

  let (ref_idxs, leaves, meds, dims, lower, upper, ppl) = buildTree refs h
  let init_leaves = map (\qi -> firstTraverse h dims qs[qi] meds) (iota m)

  -- For sorting, the queries af sorted by the initial leaves.

  let ongoing_knn   = replicate a (replicate k (-1i32, f32.inf))
  let completed_knn = copy ongoing_knn
  let stacks  = replicate a 0i32

  let (_, _, _, completed_knn, _, _, _) =
      loop (not_comp_qs, init_leaves, stacks, completed_knn, ongoing_knn, on_knn_idxs, trues) =
        (...) -- loop initialisation
          
          while (length not_comp_qs) > 0 do
            let (ongoing_knns, new_leaves, new_stacks) = unzip3 <|
                map4 (\q lidx st klst ->
                        let neighbours = bruteForce q leaves[lidx] ref_idxs[lidx] klst
                        let wknn = neighbours[k-1].1
                        let (new_l, new_s) = traverse h dims meds wknn q st lli lower upper
                        in (neighbours, new_l, new_s)
                     ) not_comp_qs init_leaves stacks ongoing_knn

            -- Sorting the queries by the leaves and getting the number of finished elements,
            -- or Partitioning the finished elements from the rest, returning the number of 
            -- not finised queries. 

            -- Gathering after sorting. 

            in (not_comp_qs'[finished:],
                ongoing_leaf_idxs[finished:],
                stacks'[finished:],
                scatter2D completed_knn (...), -- scatter completed into collective array
                ongoing_knns'[finished:],
                on_knn_idxs'[finished:],
                trues')
  in completed_knn
\end{minted}
\caption{The overall structure of the main function putting everything together.}
\label{lst:full}
\end{listing}




\subsubsection{Using Partition to Extract the Finished Queries}
\label{sec:pard}

In the missing parts on lines 25-27 in Listing \ref{lst:full}, we may insert Listing \ref{lst:par1} below, as this performs the call to partition. 

\begin{listing}[H]
\begin{minted}{haskell}
      while (length not_comp_qs) > 0 do
        (...)

        let (trues, ongoing_leaf_is, not_comp_qs', on_knn_idxs', ongoing_knns', stacks') =
            partition2 sortFinishedQueries new_leaves not_comp_qs
            ongoing_knn_idxs new_stacks ongoing_knns

        (...)
\end{minted}
\caption{The missing piece of Listing \protect{\ref{lst:full}} in the partition solution.}
\label{lst:par1}
\end{listing}

Listing \ref{lst:par2} shows the implementation of the two-way partition applied to reorganise the order of the queries, leaf indices, stacks and KNNs. The first parameter is a boolean function that checks whether the leaf indices are equal to -1, it uses this to organise all leaf indices that show completion to the right of the array and all the continuing leaf indices to the left, which results in a list of new indices, on lines 6-17. The KNNs, completed queries, leaf indices and stacks are then scattered into new arrays in the reorganised order. 

\begin{listing}[H]
\begin{minted}{haskell}
let partition2 [n][k] (expr: (i32 -> bool)) (leaf_idxs:         [n]i32)
                      (completed:   [n]i32) (knn_inds:          [n]i32)
                      (stack:       [n]i32) (knn_dsts: [n][k](i32,f32))
                      : (i32, [n]i32, [n]i32, [n]i32, [n][k](i32,f32), [n]i32) =

    let tflgs = map (\e -> if expr e then 1 else 0) leaf_idxs
    let fflgs = map (\b -> 1 - b) tflgs

    let indsT = scan (+) 0 tflgs
    let tmp   = scan (+) 0 fflgs
    let trues = if n > 0 then indsT[n-1] else -1
    let indsF = map (+trues) tmp

    let inds  = map3 (\leaf indT indF -> if expr leaf 
                                         then indT-1 
                                         else indF-1
                     ) leaf_idxs indsT indsF

    let leaf_idxsp = scatter (replicate n 0i32) inds leaf_idxs
    let completedp = scatter (replicate n 0i32) inds completed
    let knn_inds'  = scatter (replicate n 0i32) inds knn_inds
    let knn_dsts'  = scatter2D (replicate n (replicate k (0i32, 0.0f32))) inds knn_dsts 
    let stackp     = scatter (replicate n 0i32) inds stack
    in  (trues, leaf_idxsp, completedp, knn_inds', knn_dsts', stackp)
\end{minted}
\caption{Implementation of the two-way partition.}
\label{lst:par2}
\end{listing}

% Since partition is based on map, scan and scatter, it is a highly efficient solution. 




\subsubsection{Using Sorting to Extract the Finished Queries}
\label{sec:sord}

In the missing parts on line 6 and lines 25-29 in Listing \ref{lst:full}, we may insert Listing \ref{lst:par2} below, as this performs sorting of the queries by the leaves. 
Line 3-4 sort the initial leaves after the first traversal, and uses gather to reorganise the non-completed queries. Line 8 in the loop represents the call to brute force and traverse from the full implementation, once these operations are performed, lines 10-13 sort the queries by the leaves and extracts the number of completed queries as well as the ongoing ones. Thus, lines 15-18 uses the order to gather the rest of the needed arrays. 

\begin{listing}[H]
\begin{minted}{haskell}
  (...)

  let (sorted_idxs_fst, init_leaves) = init_leaves |> sort
  let not_completed_queries = gather2D sorted_idxs_fst qs

  (...)
          while (length not_comp_qs) > 0 do
            (...)

            let (ongoing_leaf_idxs, sorted_idxs) = sortQueriesByLeaves new_leaves
            let finished = map (\ll -> if ll == -1 then 1 else 0) ongoing_leaf_idxs 
                        |> reduce (+) 0
            let trues' = trues - finished

            let not_completed_queries' = gather2D sorted_idxs not_comp_qs
            let on_knn_idxs'  = gather sorted_idxs on_knn_idxs
            let ongoing_knns' = gather2Dtuples sorted_idxs new_ongoing_knns
            let stacks' = gather sorted_idxs new_stacks

            (...)
\end{minted}
\caption{The missing pieces of Listing \protect{\ref{lst:full}} in the sorting solution.}
\label{lst:sor1}
\end{listing}


\subsubsection{Why Sorting over Partition}

While partition is efficient, due to its use of map, scan and scatter, it still lacks to optimise temporal locality since all the queries are accessing the leaves in random order. By sorting the queries by the leaves before performing brute force, we can optimise temporal locality, since the leaves are then accessed in the same order. 
\\[2mm]
However, the experiments in section \ref{sec:sorpar} show that sorting is only faster when working on datasets that are approximately 500000 or larger, meaning the overhead of sorting has a higher impact compared to optimising temporal locality, for datasets smaller than 500000. 
\\[2mm]
For datasets smaller than 500000, we see that partition performs slightly better with a speed-up of nearly 1, on the other hand, for dataset between 500k-2000k, we see that sorting performs better with a speed-up between 1.5-5.


%unless the dimensionality D or K are high, in which case they can make up for the small datasets. 
% Section \ref{sec:sorpar} demonstrates the performances of these two solutions. 




% \begin{listing}[H]
% \begin{minted}{haskell}
% let sortQueriesByLeaves [n] (leaves: [n]i32) : ([n]i32, [n]i32) =
%   unzip <| merge_sort 
%                 (\ (v1,i1) (v2,i2) -> 
%                     if v1 < v2 then true  else
%                     if v1 > v2 then false else i1 <= i2 )
%                 (zip leaves (iota n))
% \end{minted}
% \caption{.}
% \label{lst:sor1}
% \end{listing}







































