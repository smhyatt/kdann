\subsection{The Full Implementation}
\label{sec:full}
% At each step you reason about tradeoffs/alternative design choices and
% justify why you did it in the way you did it (advantages/shortcommings,
% and why your approach is reasonable). Of course mostly related to performance.

% Whenever possible, support your reasoning with (as in point to) experimental
% evaluation results (next).

% 3.4 The Full Implementation
% 		- explain how things are put together - main function
% 		- reason about sorting the queries by the leaves - why is it faster? optimises locality of reference, temporal locality because by sorting the queries by the leaves the same leaves are accessed in order. 






\subsubsection{Using Partition to Extract the Finished Queries}


\begin{listing}[H]
\begin{minted}{haskell}

\end{minted}
\caption{.}
\label{lst:par}
\end{listing}




\subsubsection{Using Sorting to Extract the Finished Queries}

\begin{listing}[H]
\begin{minted}{haskell}

\end{minted}
\caption{.}
\label{lst:sor}
\end{listing}





\subsubsection{}




